{
    "title" : "Vuex how to use",
    "content" : "<p>When an app becomes complex in terms of where data is being passed between multiple components, it is time to make use of Vuex.</p><p> Vuex is a state management pattern + library for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion.</p><img src= '/img/blog/vuex/vuex.jpg'/><p><strong class='title'><em >Why use Vuex?</em></strong></p><ul><li>Every component has access to the global state</li><li>The global state is reactive, just like local state</li><li>Reduces component data tracking from becoming complex.</li><li >Vuex provides a state pattern to make updates standardized.</li></ul><p>To set up Vuex you have to install the npm package.</p><p class='title'><strong ><em>npm i vuex --save</em></p></strong><p>Inside the src folder, we can now set up a store.js file.</p><p>Heres how the store.js file would look.</p><a target='_blank' href ='https://gist.github.com/harrybeckwith/6fe034711593f2f443a76c5e4c82fcc2'><img src ='/img/blog/vuex/gist-1.png'/> </a><p>Inside main.js we can link the store to the Vue instance by importing the store file and added to Vue‚Ä¶</p><a target='_blank' href ='https://gist.github.com/harrybeckwith/7f41783287373e076952e9b9589e0215'><img src ='/img/blog/vuex/gist-2.png'/> </a><p>Right now we have the store set up ü•≥ but we cannot access or edit yet üòï.</p><p><strong><em>How to work with the store (vuex)</em></strong></p><img src= '/img/blog/vuex/vuex-1.png'/><p><strong><em>Mutations.</em></strong></p><ul><li>Commit + track state changes</li><li>The best practice is for actions to call mutations then mutations update the state directly.</li><li>Using the dev tools we can roll back mutations back to the previous state value.</li></ul><img src= '/img/blog/vuex/vuex-2.png'/><p><strong><em>Getting the state from Vuex into computed properties.</em></strong></p><p>Inside the store.js we can create getters, these interact directly with the state in the store. They are used to get the state. We can then display the getters inside components through computed properties.</p><a href ='https://vuex.vuejs.org/guide/getters.html'>Documentation for getters here.</a><p><strong><em>Store.js</em></strong> file with state and getters set up.</p><a target='_blank' href ='https://gist.github.com/harrybeckwith/2cb75f97cdb289e86753f7e402c8b5ea'><img src ='/img/blog/vuex/gist-3.png'/></a><p><strong><em>How to link the getters to components?</em></strong></p><p>Use computed properties, but first, we can map the getters for easy access like so.</p><a target='_blank' href ='https://gist.github.com/harrybeckwith/36e6aafd7cdcdfd2929dc9a0d363ea50'><img src ='/img/blog/vuex/gist-4.png'/></a><p>You have to import { mapGetters } from Vuex to be able to place inside the computed properties. Using the spread operator and pacing each getter as a string array item we can then reference individual getters inside the template.</p><p>We can also create getters that take arguments which are then used as a computed property and take input inside the template. The example for this is the getter getEventById in the above two code blocks.</p><strong><em>Mutations</em><p></strong><ul><li>Can update/mutate Vuex State.</li><li>They are synchronous, they happen one after another.</li></ul><a target='_blank' href='https://vuex.vuejs.org/guide/mutations.html'>Mutations documentation here.</a></p><strong><em>Actions</em></strong><ul><li>Are asynchronous, they may not happen in the order they appear in the code.</li><li>Can wrap business logic around mutations</li><li>Always put Mutations within Actions ‚Äî as business logic, later on, would be easy to apply, this increases the scalability.</li></ul><p><a target='_blank' href='https://vuex.vuejs.org/guide/actions.html'>Actions documentation here.</a></p><a target='_blank' href ='https://gist.github.com/harrybeckwith/54afd2e8afb510741efad98a5fd2bb2d'><img src ='/img/blog/vuex/gist-4.png'/></a><p>Here we can see that mutation has been created that takes an event and pushes to the events array. The action is the code that we will dispatch to from the component, in turn, this calls the mutation and updates the store state.</p><p>Let's see how to call the action inside a component.</p><strong><em>this.$store.dispatch('createEvent', this.event)</em></strong><p>Referencing the store and dispatch with the name that matches actions function name, this will now send the this. event data into the action, then call the mutation and update the state.</p><p>Using the pattern above is a way to set up and use Vuex as the data point in your application was helps avoid tracking through components to see where the data needs to pass to. This can become bloated in larger applications so a module approach is needed to aid larger apps. Documentation can be found <a href='https://vuex.vuejs.org/guide/modules.html'>here</a>.</p><p>That's the basics of Vuex, cheers ‚òïÔ∏è</p>"
}